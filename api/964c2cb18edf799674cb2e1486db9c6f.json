{"title":"设计模式学习-设计原则","slug":"设计模式-设计原则","url":"http://share.ra.com/设计模式-设计原则","date":"2017-09-22T01:47:37.000Z","updated":"2017-12-20T14:40:49.917Z","comments":true,"excerpt":"","tags":["Swift","DesignPattern"],"content":"<h4 id=\"1、单一职责原则\"><a href=\"#1、单一职责原则\" class=\"headerlink\" title=\"1、单一职责原则\"></a>1、单一职责原则</h4><ul>\n<li>就一个类而言，应该仅有一个引起它变化的原因</li>\n</ul>\n<p>如果一个雷承担的职责过多，就等于吧这些职责耦合在一起，一个职责的变化可能会小若或者一直这个类完成其它职责的能力，这种耦合会导致脆弱的设计，当需求变化时，可能会导致大面积的破坏</p>\n<h4 id=\"2、开放封闭原则\"><a href=\"#2、开放封闭原则\" class=\"headerlink\" title=\"2、开放封闭原则\"></a>2、开放封闭原则</h4><ul>\n<li>类、模块、函数等应该可以扩展但是不可以修改</li>\n<li>对于扩展是开放的(open for extension)</li>\n<li>对于修改是封闭的(closed for modification)</li>\n</ul>\n<h4 id=\"3、依赖倒转原则\"><a href=\"#3、依赖倒转原则\" class=\"headerlink\" title=\"3、依赖倒转原则\"></a>3、依赖倒转原则</h4><ul>\n<li>抽象不应该依赖细节，细节应该依赖于抽象（面向接口，不要面向实现）</li>\n<li>高层模块不应该依赖底层模块。都应该依赖抽象</li>\n</ul>\n<h4 id=\"4、里式代换原则\"><a href=\"#4、里式代换原则\" class=\"headerlink\" title=\"4、里式代换原则\"></a>4、里式代换原则</h4><ul>\n<li>子类型必须能够替换掉他们的父类型</li>\n</ul>\n<h4 id=\"5、迪米特法则（最少知识原则）\"><a href=\"#5、迪米特法则（最少知识原则）\" class=\"headerlink\" title=\"5、迪米特法则（最少知识原则）\"></a>5、迪米特法则（最少知识原则）</h4><ul>\n<li>如果两个类不必彼此直接通信，那么这两个类就不应该发生直接相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转达这个调用</li>\n<li>强调类之间松耦合，在类的结构设计上每一个类都应该当尽量降低成员访问权限</li>\n<li>耦合越弱越有利于复用</li>\n</ul>\n","prev":{"title":"设计模式学习-原型模式","slug":"设计模式-原型模式"},"next":{"title":"RxSwift (二) Working with Subjects","slug":"RxSwift (二) Working with Subjects"}}